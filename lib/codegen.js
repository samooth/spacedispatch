const s = require('generate-string')

module.exports = function generateCode (hyperdispatch) {
  let str = ''
  str += '// This file is autogenerated by the hyperdispatch compiler\n'
  str += '/* eslint-disable camelcase */\n'
  str += '\n'
  str += 'const { c, b4a, assert } = require(\'hyperdispatch/runtime\')\n'
  str += 'const { version, getEncoding, setVersion } = require(\'./messages.js\')\n'
  str += '\n'
  str += 'const defaultVersion = version\n'
  str += '\n'

  str += 'class Router {\n'
  str += '  constructor () {\n'
  for (const handler of hyperdispatch.handlers) {
    str += `    this._handler${handler.id} = null\n`
  }
  str += '\n'
  str += `    this._missing = ${hyperdispatch.handlers.length}\n`
  str += '  }\n'
  str += '\n'
  str += '  add (name, handler) {\n'
  str += '    switch (name) {\n'
  for (const handler of hyperdispatch.handlers) {
    str += `      case ${s(handler.name)}:\n`
    str += `        this._handler${handler.id} = handler\n`
    str += '        break\n'
  }
  str += '      default:\n'
  str += '        throw new Error(\'Cannot register a handler for a nonexistent route: \' + name)\n'
  str += '    }\n'
  str += '    this._missing--\n'
  str += '  }\n'
  str += '\n'
  str += '  _checkAll () {\n'
  for (const handler of hyperdispatch.handlers) {
    str += `    assert(this._handler${handler.id} !== null, 'Missing handler for ${JSON.stringify(handler.name)}')\n`
  }
  str += '  }\n'
  str += '\n'
  str += '  async dispatch (encoded, context) {\n'
  str += '    if (this._missing > 0) {\n'
  str += '      this._checkAll()\n'
  str += '    }\n'
  str += '\n'
  str += '    const state = { buffer: encoded, start: 0, end: encoded.byteLength }\n'
  str += '    const id = c.uint.decode(state)\n'
  str += '\n'
  str += '    setVersion(defaultVersion)\n'
  str += '\n'
  str += '    switch (id) {\n'
  for (const handler of hyperdispatch.handlers) {
    str += `      case ${handler.id}:\n`
    str += `        return this._handler${handler.id}(route${handler.id}.enc.decode(state), context)\n`
  }
  str += '      default:\n'
  str += '        throw new Error(\'Handler not found for ID:\' + id)\n'
  str += '    }\n'
  str += '  }\n'
  str += '}\n'

  str += '\n'

  str += 'function dispatch (name, message, { version = defaultVersion } = {}) {\n'
  str += '  const state = { buffer: null, start: 0, end: 0 }\n'
  str += '\n'
  str += '  const o = getEncoderAndId(name)\n'
  str += '  setVersion(version)\n'
  str += '\n'
  str += '  c.uint.preencode(state, o.id)\n'
  str += '  o.enc.preencode(state, message)\n'
  str += '\n'
  str += '  state.buffer = b4a.allocUnsafe(state.end)\n'
  str += '  c.uint.encode(state, o.id)\n'
  str += '  o.enc.encode(state, message)\n'
  str += '\n'
  str += '  return state.buffer\n'
  str += '}\n'
  str += '\n'

  for (const handler of hyperdispatch.handlers) {
    str += 'const route' + handler.id + ' = {\n'
    str += `  id: ${handler.id},\n`
    str += `  enc: getEncoding(${s(handler.requestType)})\n`
    str += '}\n'
    str += '\n'
  }

  str += 'function getEncoderAndId (name) {\n'
  str += '  switch (name) {\n'
  for (const handler of hyperdispatch.handlers) {
    str += `    case ${s(handler.name)}:\n`
    str += `      return route${handler.id}\n`
  }
  str += '    default:\n'
  str += '      throw new Error(\'Handler not found for name: \' + name)\n'
  str += '  }\n'
  str += '}\n'

  str += '\n'

  str += 'module.exports = {\n'
  str += '  version,\n'
  str += '  dispatch,\n'
  str += '  Router\n'
  str += '}\n'

  return str
}
